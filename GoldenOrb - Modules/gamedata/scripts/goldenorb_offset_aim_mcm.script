----------------------------------------------------------------------------
-- GoldenOrb: Offset Aim Camera Modifier
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- HUD offset rotation
local goldenorb_before_modify_state = goldenorb_main.goldenorb_before_modify_state
local goldenorb_after_modify_state = goldenorb_main.goldenorb_after_modify_state

--- Aim
local page = goldenorb_aim_mcm.page
local aim_type = goldenorb_aim_mcm.aim_type
local AIM_OFFSET = goldenorb_aim_mcm.AIM_OFFSET

--- String
local parse_vector = goldenorb_string.parse_vector

--- Schedule
local LEVEL_CALL = goldenorb_schedule.LEVEL_CALL
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- MCM Builder
local Line = mcm_builder.Line
local Title = mcm_builder.Title
local InputField = mcm_builder.InputField

--- Math
local PI = lander_math.PI
local RAD2DEG = lander_math.RAD2DEG

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Offset Aim",
   goldenorb_logging.WARNING
)

-- State

--- MCM Title
page:settings(
   Line.new(),
   Title.new("offset_aim_title"):text("offset_aim")
)

--- MCM Settings
local sensitivity = page:settings(
   InputField.new("sensitivity")
      :default("1.0,1.0")
)

-- Implementation

offset_aim = system("offset_aim")
   :runs_after(goldenorb_before_modify_state)
   :runs_before(goldenorb_after_modify_state)
   :reads("joint_aim", "spring_aim", "cam")
   :inputs({
      cam = {
         matrix_delta = I_READ,
      },
      hud = {
         hands_orientation = I_READ,
      }
   })
   :writes("joint_aim")
   :outputs({
      hud = {
         hands_orientation = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_OFFSET
   end)
   :via(function(state)
      local delta_rot = state.cam.matrix_delta:getHPB()
      log("  delta_rot: %s", delta_rot)

      local joint_aim = state.joint_aim
         :impulse(
            delta_rot
            :mul(parse_vector(sensitivity:get()))
         )

      joint_aim
         :impulse_with(state.spring_aim.spring)

      return {
         joint_aim = joint_aim,
         hud = {
            hands_orientation = vector():set(state.hud.hands_orientation)
               :add(vector():set(joint_aim.vec):mul(RAD2DEG))
         }
      }
   end)
   :during(LEVEL_CALL)
