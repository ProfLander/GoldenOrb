----------------------------------------------------------------------------
-- GoldenOrb: Recoil
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Schedule
local ACTOR_ON_UPDATE = goldenorb_schedule.ACTOR_ON_UPDATE
local ACTOR_ON_WEAPON_FIRED = goldenorb_schedule.ACTOR_ON_WEAPON_FIRED
local LEVEL_CALL = goldenorb_schedule.LEVEL_CALL

--- Main
local goldenorb_after_modify_state = goldenorb_main.goldenorb_after_modify_state
local goldenorb_before_apply_state = goldenorb_main.goldenorb_before_apply_state

--- Weapon
local inject_weapon = goldenorb_weapon.inject_weapon

--- Lens
local lens = goldenorb_lens.lens

--- Spring
local spring_1d = goldenorb_spring.spring_1d
local SP_ANGULAR = goldenorb_spring.SP_ANGULAR

--- Table
local foreach = goldenorb_table.foreach

--- Math
local deg = lander_math.deg

--- Schedule
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- MCM Builder
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Recoil",
   goldenorb_logging.TRACE
)

-- Constants

--- Lenses for interacting with weapon parameters
local lenses = {
   cam_relax_speed = lens(
      "GetCamRelaxSpeed",
      "SetCamRelaxSpeed"
   ),
   cam_dispersion = lens(
      "GetCamDispersion",
      "SetCamDispersion"
   ),
   cam_dispersion_inc = lens(
      "GetCamDispersionInc",
      "SetCamDispersionInc"
   ),
   cam_dispersion_frac = lens(
      "GetCamDispersionFrac",
      "SetCamDispersionFrac"
   ),
   cam_max_angle_vert = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   cam_max_angle_horz = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   cam_step_angle_horz = lens(
      "GetCamStepAngleHorz",
      "SetCamStepAngleHorz"
   ),
   zoom_cam_relax_speed = lens(
      "GetZoomCamRelaxSpeed",
      "SetZoomCamRelaxSpeed"
   ),
   zoom_cam_dispersion = lens(
      "GetZoomCamDispersion",
      "SetZoomCamDispersion"
   ),
   zoom_cam_dispersion_inc = lens(
      "GetZoomCamDispersionInc",
      "SetZoomCamDispersionInc"
   ),
   zoom_cam_dispersion_frac = lens(
      "GetZoomCamDispersionFrac",
      "SetZoomCamDispersionFrac"
   ),
   zoom_cam_max_angle_vert = lens(
      "GetZoomCamMaxAngleHorz",
      "SetZoomCamMaxAngleHorz"
   ),
   zoom_cam_max_angle_horz = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   zoom_cam_step_angle_horz = lens(
      "GetZoomCamStepAngleHorz",
      "SetZoomCamStepAngleHorz"
   ),
}

-- State

local page = tree:pages("recoil")

local kick_multiplier, control_strength = page:settings(
   Trackbar.new("kick_multiplier")
      :default(8)
      :minmax(1, 32)
      :increment(1),
   Trackbar.new("control_strength")
      :default(0.05)
      :minmax(0, 1)
      :increment(0.01)
)

--- Weapon data cache
local wpn_cache = {}

--- How under-control the weapon is
local control_fac = 0

--- Recoil matrix
local recoil_mat = matrix():identity()

--- Recoil spring
local recoil_spring = goldenorb_spring.mcm_spring(
   page,
   SP_ANGULAR,
   "0,0",
   "0.05,0.05"
)

-- Implementation

--- Cache a weapon's HUD data before setting it all to 0
consume_weapon = system("consume_weapon")
   :runs_after(inject_weapon)
   :reads("wpn")
   :via(function(state)
      -- Fetch the weapon's section
      local sec = state.wpn:section()
      log("  section(%s)", sec)

      -- Return with a warning if it's not valid
      if not sec then
         log:warning("  WARNING: Invalid weapon section")
         return
      end

      -- Return if it's already set
      if wpn_cache[sec] then
         log:info("  %s is already cached, returning.", sec)
         return
      end

      -- Fetch existing cache data
      wpn_cache[sec] = {}

      -- Cast our weapon to a CWeapon
      local weapon = state.wpn:cast_Weapon()

      if not weapon then
         log:warning("  WARNING: Invalid weapon")
         return
      end

      -- Iterate over our parameter lenses
      foreach(
         lenses,
         function(k, l)
            wpn_cache[sec][k] = l:get(weapon)
            l:set(weapon, 0)
         end
      )
   end)
   :during(ACTOR_ON_UPDATE)

--- Apply recoil forces on weapon discharge
recoil_weapon = system("recoil_weapon")
   :reads("wpn")
   :via(function(state)
      control_fac = control_fac + kick_multiplier:get()

      local id = state.wpn:id()
      log("  id: %s", id)

      local sec = state.wpn:section()
      log("  sec: %s", sec)

      local cache = wpn_cache[sec]
      if not cache then
         log:info("No cached recoil information")
         return
      end

      -- Fetch weapon recoil stats
      local wpn_disp = nil
      local wpn_frac = nil
      local wpn_inc = nil
      local wpn_max_vert = nil
      local wpn_max_horz = nil
      local wpn_step_horz = nil

      if axr_main.weapon_is_zoomed then
         wpn_disp = cache.zoom_cam_dispersion
         wpn_frac = cache.zoom_cam_dispersion_frac
         wpn_inc = cache.zoom_cam_dispersion_inc
         wpn_max_vert = cache.zoom_cam_max_angle_vert
         wpn_max_horz = cache.zoom_cam_max_angle_horz
         wpn_step_horz = cache.zoom_cam_step_angle_horz
      else
         wpn_disp = cache.cam_dispersion
         wpn_frac = cache.cam_dispersion_frac
         wpn_inc = cache.cam_dispersion_inc
         wpn_max_vert = cache.cam_max_angle_vert
         wpn_max_horz = cache.cam_max_angle_horz
         wpn_step_horz = cache.cam_step_angle_horz
      end

      -- Gather ammo box list
      local ammo_list_n = utils_item.get_ammo(sec, id)

      -- Gather weapon info
      local ammo_type = state.wpn:get_ammo_type()
      local ammo_sec = ammo_list_n[ammo_type + 1]
      ---@diagnostic disable-next-line: undefined-field
      local ammo_disp = ini_sys:r_float_ex(ammo_sec, "k_cam_disp") or 1

      -- Fetch silencer recoil stats
      ---@diagnostic disable-next-line: undefined-field
      local silencer = ini_sys:r_string_ex(sec, "silencer_name")
      log("  silencer: %s", silencer)

      local silencer_disp = silencer
         ---@diagnostic disable-next-line: undefined-field
         and ini_sys:r_string_ex(silencer, "cam_dispersion_k") or 1
      local silencer_inc = silencer
         ---@diagnostic disable-next-line: undefined-field
         and ini_sys:r_string_ex(silencer, "cam_dispersion_inc_k") or 1

      log("  silencer_disp: %s", silencer_disp)
      log("  silencer_inc: %s", silencer_inc)

      local disp = wpn_disp * silencer_disp * ammo_disp
      local inc = wpn_inc * silencer_inc * (control_fac + 1)

      local ang = disp + inc

      local rnd = (math.random() - 1) * 2
      local recoil_y = ang * (wpn_frac + rnd * (1 - wpn_frac))
      log("  recoil_y: %s", recoil_y)

      rnd = (math.random() - 1) * 2
      local recoil_x = (recoil_mat.c.y / wpn_max_vert) * rnd * wpn_step_horz
      log("  recoil_x: %s", recoil_x)

      recoil_mat = matrix():mul(
         recoil_mat,
         matrix():setHPB(recoil_x, recoil_y, 0)
      )
      log("  recoil_mat: %s", recoil_mat)
   end)
   :during(ACTOR_ON_WEAPON_FIRED)

--- Integrate recoil forces and apply to the HUD
integrate_recoil = system("integrate_recoil")
      :runs_after(goldenorb_after_modify_state)
   :runs_before(goldenorb_before_apply_state)
   :inputs({
      hud = {
         hands_orientation = I_READ
      }
   })
   :outputs({
      hud = {
         hands_orientation = O_WRITE
      }
   })
   :via(function(state)
      control_fac = control_fac + spring_1d(
         0,
         control_strength:get(),
         control_fac
      )
      log("  control_fac: %s", control_fac)

      local hpb = recoil_mat:getHPB()
      log("  hpb: %s", hpb)

      hpb = recoil_spring.spring(hpb)
      log("  spring hpb: %s", hpb)

      recoil_mat = matrix():mul(
         recoil_mat,
         matrix():setHPB(hpb.x, hpb.y, hpb.z)
      )
      log("  recoil_mat: %s", recoil_mat)

      hpb = recoil_mat:getHPB()
      log("  hpb: %s", hpb)

      return {
         hud = {
            hands_orientation = state.hud.hands_orientation:add(
               vector():set(
                  deg(hpb.x),
                  deg(hpb.y),
                  deg(hpb.z)
               )
            )
         }
      }
   end)
   :during(LEVEL_CALL)
