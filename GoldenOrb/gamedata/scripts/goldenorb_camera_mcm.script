----------------------------------------------------------------------------
-- GoldenOrb: Camera State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Main
local ACTOR_ON_UPDATE = goldenorb_main.ACTOR_ON_UPDATE
local phase_build_state = goldenorb_main.phase_build_state
local phase_modify_state = goldenorb_main.phase_modify_state
local phase_apply_state = goldenorb_main.phase_apply_state
local phase_done = goldenorb_main.phase_done
local handle_error = goldenorb_main.handle_error

--- Function
local protected = goldenorb_function.protected

--- Schedule
local I_NOT_EXIST = goldenorb_schedule.I_NOT_EXIST
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- Level
local set_cam_custom_position_direction = level.set_cam_custom_position_direction
local remove_cam_custom_position_direction = level.remove_cam_custom_position_direction

--- MCM Builder
local ImageWithText = mcm_builder.ImageWithText
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Camera",
    goldenorb_logging.WARNING
)

-- Constants

local DIST = 800

-- State

local page = tree:pages("camera")

page:settings(
   ImageWithText.new("camera_title"):text("camera")
)

local smoothing = page:settings(
   Trackbar.new("smoothing")
      :default(-1)
      :minmax(-1, 60)
      :increment(1)
)

local cam_custom = false

local prev_pos = vector()
local prev_rot = vector()

local delta_pos = vector()
local delta_rot = vector()

-- Implementation

--- Rotation getter
---@return vector
function get_camera_position()
   return device().cam_pos
end

---@return vector
function get_camera_direction()
   return device().cam_dir
end

---@return vector
function get_camera_rotation()
   local dir = get_camera_direction()
   return vector():set(
      math.atan2(dir.x, dir.z),
      math.sin(dir.y),
      0
   )
end

--- Delta position getter
---@return vector
function get_camera_delta_position()
   return delta_pos
end

--- Delta rotation getter
---@return vector
function get_camera_delta_rotation()
   return delta_rot
end

--- Aim point getter
---@return vector
function get_camera_aim_point()
   log:trace("get_camera_aim_point(%s)")
   local dev = device()
   return dev.cam_dir:mul(DIST):add(dev.cam_pos)
end

---@class state_cam
---@field enable boolean
---@field pos vector
---@field rot vector
---@field smoothing number
---@field show_hud boolean
---@field affect_hud boolean

--- Inject default camera parameters into the state
---@param state table
---@return table
function inject_camera(state)
   log:trace("inject_camera(%s)", state)

   return {
      cam = {
         enable = false,
         pos = vector(),
         rot = vector(),
         smoothing = smoothing:get(),
         show_hud = true,
         affect_hud = true,
      }
   }
end

--- Update function
---@param state table
---@return table
function read_camera(state)
   log:trace("read_camera(%s)", state)

   local dev = device()
   local pos = dev.cam_pos

   delta_pos = vector():set(pos):sub(prev_pos)
   log:trace("  delta_pos: %s", delta_pos)

   local cam_rot = get_camera_rotation()
   delta_rot = vector():set(cam_rot):sub(prev_rot)
   log:trace("  delta_rot: %s", delta_rot)

   prev_pos = pos
   prev_rot = cam_rot

   return {}
end

---Apply the state's camera values to the game
---@param state table
---@return table
function apply_camera(state)
   log:trace("apply_camera(%s)", state)

   if state.cam.enable then
      log:info("  Applying camera state")
      set_cam_custom_position_direction(
         state.cam.pos,
         state.cam.rot,
         state.cam.smoothing,
         state.cam.show_hud,
         state.cam.affect_hud
      )
      cam_custom = true
   elseif cam_custom then
      log:info("  Resetting camera state.")
      remove_cam_custom_position_direction()
      cam_custom = false
   end

   return {}
end

---Initialization handler
---@return nil
function init_camera()
   local dev = device()
   prev_pos = dev.cam_pos
   prev_rot = dev.cam_dir
end

---@return nil
on_game_start = protected(
   handle_error,
   function()
      ACTOR_ON_UPDATE
         :insert(
            inject_camera,
            {phase_build_state},
            {phase_modify_state},
            {cam = I_NOT_EXIST},
            {cam = O_WRITE}
         )
         :insert(
            read_camera,
            {inject_camera},
            {phase_modify_state}
         )
         :insert(
            apply_camera,
            {phase_apply_state},
            {phase_done},
            {cam = I_READ}
         )

      RegisterScriptCallback("actor_on_first_update", init_camera)
   end
)
