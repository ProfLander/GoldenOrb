----------------------------------------------------------------------------
-- GoldenOrb: Camera State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Main
local ACTOR_ON_UPDATE = goldenorb_main.ACTOR_ON_UPDATE
local phase_build_state = goldenorb_main.phase_build_state
local phase_modify_state = goldenorb_main.phase_modify_state
local phase_apply_state = goldenorb_main.phase_apply_state
local phase_done = goldenorb_main.phase_done
local handle_error = goldenorb_main.handle_error

--- Function
local protected = goldenorb_function.protected

--- Schedule
local I_NOT_EXIST = goldenorb_schedule.I_NOT_EXIST
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- Level
local set_cam_custom_position_direction = level.set_cam_custom_position_direction
local remove_cam_custom_position_direction = level.remove_cam_custom_position_direction

--- MCM Builder
local ImageWithText = mcm_builder.ImageWithText
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Camera",
    goldenorb_logging.TRACE
)

-- Constants

local DIST = 1000

-- State

local page = tree:pages("camera")

page:settings(
   ImageWithText.new("camera_title"):text("camera")
)

local smoothing = page:settings(
   Trackbar.new("smoothing")
      :default(-1)
      :minmax(-1, 60)
      :increment(1)
)

local cam_custom = false

local prev_pos = nil
local prev_rot = nil

local delta_pos = vector()
local delta_rot = vector()

-- Implementation

--- Rotation getter
---@return vector
function get_camera_position(state)
   return vector():set(state.dev.cam_pos)
end

---@return vector
function get_camera_direction(state)
   return vector():set(state.dev.cam_dir)
end

---@return vector
function get_camera_rotation(state)
   local dir = get_camera_direction(state)
   return vector():set(
      math.atan2(dir.x, dir.z),
      math.sin(dir.y),
      0
   )
end

--- Aim point getter
---@return vector
function get_camera_aim_point(state)
   log:trace("get_camera_aim_point(%s)", state)
   return get_camera_direction(state)
      :mul(DIST)
      :add(get_camera_position(state))
end

--- Delta position getter
---@return vector
function get_camera_delta_position()
   return delta_pos
end

--- Delta rotation getter
---@return vector
function get_camera_delta_rotation()
   return delta_rot
end

---@class state_cam
---@field enable boolean
---@field pos vector
---@field rot vector
---@field smoothing number
---@field show_hud boolean
---@field affect_hud boolean

--- Inject device into the state
---@param state table
---@return table
function inject_device(state)
   log:trace("inject_device(%s)", state)

   local dev = device()
   return {
      dev = {
         width = dev.width,
         height = dev.height,
         aspect_ratio = dev.aspect_ratio,
         fov = dev.fov,
         frame = dev.frame,
         precache_frame = dev.precache_frame,
         time_delta = dev.time_delta,
         f_time_delta = dev.f_time_delta,
         cam_pos = vector():set(dev.cam_pos),
         cam_right = vector():set(dev.cam_right):normalize(),
         cam_top = vector():set(dev.cam_top):normalize(),
         cam_dir = vector():set(dev.cam_dir):normalize(),
      }
   }
end

--- Inject default camera parameters into the state
---@param state table
---@return table
function inject_camera(state)
   log:trace("inject_camera(%s)", state)

   return {
      cam = {
         enable = false,
         pos = vector(),
         rot = vector(),
         smoothing = smoothing:get(),
         show_hud = true,
         affect_hud = true,
      }
   }
end

--- Update function
---@param state table
---@return table
function read_camera(state)
   log:trace("read_camera(%s)", state)

   local cam_pos = get_camera_position(state)
   local cam_rot = get_camera_rotation(state)

   if prev_pos then
      delta_pos = vector():set(cam_pos):sub(prev_pos)
      log:trace("  delta_pos: %s", delta_pos)
   end

   if prev_rot then
      delta_rot = vector():set(cam_rot):sub(prev_rot)
      log:trace("  delta_rot: %s", delta_rot)
   end

   prev_pos = cam_pos
   prev_rot = cam_rot

   return {}
end

---Apply the state's camera values to the game
---@param state table
---@return table
function apply_camera(state)
   log:trace("apply_camera(%s)", state)

   if state.cam.enable then
      log:info("  Applying camera state")
      set_cam_custom_position_direction(
         state.cam.pos,
         state.cam.rot,
         state.cam.smoothing,
         state.cam.show_hud,
         state.cam.affect_hud
      )
      cam_custom = true
   elseif cam_custom then
      log:info("  Resetting camera state.")
      remove_cam_custom_position_direction()
      cam_custom = false
   end

   return {}
end

---@return nil
ACTOR_ON_UPDATE
   :insert(
      inject_device,
      {phase_build_state},
      {phase_modify_state},
      {dev = I_NOT_EXIST},
      {dev = O_WRITE}
   )
   :insert(
      inject_camera,
      {phase_build_state, inject_device},
      {phase_modify_state},
      {
         dev = I_READ,
         cam = I_NOT_EXIST
      },
      {cam = O_WRITE}
   )
   :insert(
      read_camera,
      {phase_build_state, inject_device, inject_camera},
      {phase_modify_state},
      {dev = I_READ}
   )
   :insert(
      apply_camera,
      {phase_apply_state},
      {phase_done},
      {cam = I_READ}
   )
