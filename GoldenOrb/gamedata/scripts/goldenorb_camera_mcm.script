----------------------------------------------------------------------------
-- GoldenOrb: Camera State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Schedule
local ACTOR_ON_UPDATE = goldenorb_schedule.ACTOR_ON_UPDATE
local LEVEL_CALL = goldenorb_schedule.LEVEL_CALL

--- Main
local goldenorb_before_build_state = goldenorb_main.goldenorb_before_build_state
local goldenorb_after_build_state = goldenorb_main.goldenorb_after_build_state
local goldenorb_before_apply_state = goldenorb_main.goldenorb_before_apply_state
local goldenorb_after_apply_state = goldenorb_main.goldenorb_after_apply_state

--- Schedule
local system = goldenorb_schedule.system

--- Level
local set_cam_custom_position_direction = level.set_cam_custom_position_direction
local remove_cam_custom_position_direction = level.remove_cam_custom_position_direction

--- MCM Builder
local ImageWithText = mcm_builder.ImageWithText
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Camera",
    goldenorb_logging.TRACE
)

-- Constants

local DIST = 1000

-- State

local page = tree:pages("camera")

page:settings(
   ImageWithText.new("camera_title"):text("camera")
)

local smoothing = page:settings(
   Trackbar.new("smoothing")
      :default(-1)
      :minmax(-1, 60)
      :increment(1)
)

local cam_custom = false

local prev_pos = nil
local prev_rot = nil

local delta_pos = vector()
local delta_rot = vector()

-- Implementation

--- Rotation getter
---@return vector
function get_camera_position()
   return device().cam_pos
end

---@return vector
function get_camera_direction()
   return device().cam_dir
end

---@return vector
function get_camera_rotation()
   local dir = get_camera_direction()
   return vector():set(
      math.atan2(dir.x, dir.z),
      math.sin(dir.y),
      0
   )
end

--- Aim point getter
---@return vector
function get_camera_aim_point()
   log:trace("get_camera_aim_point()")
   return device().cam_dir
      :mul(DIST)
      :add(device().cam_pos)
end

--- Delta position getter
---@return vector
function get_camera_delta_position()
   return delta_pos
end

--- Delta rotation getter
---@return vector
function get_camera_delta_rotation()
   return delta_rot
end

---@class state_cam
---@field enable boolean
---@field pos vector
---@field rot vector
---@field smoothing number
---@field show_hud boolean
---@field affect_hud boolean

--- Inject device into the state
inject_device = system("inject_device")
   :runs_after(goldenorb_before_build_state)
   :runs_before(goldenorb_after_build_state)
   :writes("dev")
   :via(function()
      local dev = device()
      return {
         dev = {
            width = dev.width,
            height = dev.height,
            aspect_ratio = dev.aspect_ratio,
            fov = dev.fov,
            frame = dev.frame,
            precache_frame = dev.precache_frame,
            time_delta = dev.time_delta,
            f_time_delta = dev.f_time_delta,
            cam_pos = vector():set(dev.cam_pos),
            cam_right = vector():set(dev.cam_right):normalize(),
            cam_top = vector():set(dev.cam_top):normalize(),
            cam_dir = vector():set(dev.cam_dir):normalize(),
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Inject default camera parameters into the state
inject_camera = system("inject_camera")
   :runs_after(inject_device)
   :runs_before(goldenorb_after_build_state)
   :reads("dev")
   :writes("cam")
   :via(function()
      return {
         cam = {
            enable = false,
            pos = vector(),
            rot = vector(),
            smoothing = smoothing:get(),
            show_hud = true,
            affect_hud = true,
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Cache camera parameters into module variables
read_camera = system("read_camera")
   :runs_after(inject_device, inject_camera)
   :runs_before(goldenorb_after_build_state)
   :reads("dev")
   :via(function()
      local cam_pos = get_camera_position()
      local cam_rot = get_camera_rotation()

      if prev_pos then
         delta_pos = vector():set(cam_pos):sub(prev_pos)
         log:trace("  delta_pos: %s", delta_pos)
      end

      if prev_rot then
         delta_rot = vector():set(cam_rot):sub(prev_rot)
         log:trace("  delta_rot: %s", delta_rot)
      end

      prev_pos = cam_pos
      prev_rot = cam_rot
   end)
   :during(ACTOR_ON_UPDATE)

--- Apply camera parameters to the game state
apply_camera = system("apply_camera")
   :runs_after(goldenorb_before_apply_state)
   :runs_before(goldenorb_after_apply_state)
   :reads("cam")
   :via(function(state)
      if state.cam.enable then
         log:info("  Applying camera state")
         set_cam_custom_position_direction(
            state.cam.pos,
            state.cam.rot,
            state.cam.smoothing,
            state.cam.show_hud,
            state.cam.affect_hud
         )
         cam_custom = true
      elseif cam_custom then
         log:info("  Resetting camera state.")
         remove_cam_custom_position_direction()
         cam_custom = false
      end
   end)
   :during(LEVEL_CALL)

