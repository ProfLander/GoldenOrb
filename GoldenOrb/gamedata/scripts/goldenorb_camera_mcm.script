----------------------------------------------------------------------------
-- GoldenOrb: Camera State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Main
local ACTOR_ON_UPDATE = goldenorb_main.ACTOR_ON_UPDATE
local phase_build_state = goldenorb_main.phase_build_state
local phase_modify_state = goldenorb_main.phase_modify_state
local phase_apply_state = goldenorb_main.phase_apply_state
local phase_done = goldenorb_main.phase_done

--- Schedule
local system = goldenorb_schedule.system

--- Level
local set_cam_custom_position_direction = level.set_cam_custom_position_direction
local remove_cam_custom_position_direction = level.remove_cam_custom_position_direction

--- MCM Builder
local ImageWithText = mcm_builder.ImageWithText
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Camera",
    goldenorb_logging.TRACE
)

-- Constants

local DIST = 1000

-- State

local page = tree:pages("camera")

page:settings(
   ImageWithText.new("camera_title"):text("camera")
)

local smoothing = page:settings(
   Trackbar.new("smoothing")
      :default(-1)
      :minmax(-1, 60)
      :increment(1)
)

local cam_custom = false

local prev_pos = nil
local prev_rot = nil

local delta_pos = vector()
local delta_rot = vector()

-- Implementation

--- Rotation getter
---@return vector
function get_camera_position(state)
   return vector():set(state.dev.cam_pos)
end

---@return vector
function get_camera_direction(state)
   return vector():set(state.dev.cam_dir)
end

---@return vector
function get_camera_rotation(state)
   local dir = get_camera_direction(state)
   return vector():set(
      math.atan2(dir.x, dir.z),
      math.sin(dir.y),
      0
   )
end

--- Aim point getter
---@return vector
function get_camera_aim_point(state)
   log:trace("get_camera_aim_point(%s)", state)
   return get_camera_direction(state)
      :mul(DIST)
      :add(get_camera_position(state))
end

--- Delta position getter
---@return vector
function get_camera_delta_position()
   return delta_pos
end

--- Delta rotation getter
---@return vector
function get_camera_delta_rotation()
   return delta_rot
end

---@class state_cam
---@field enable boolean
---@field pos vector
---@field rot vector
---@field smoothing number
---@field show_hud boolean
---@field affect_hud boolean

--- Inject device into the state
inject_device = system("inject_device")
   :runs_after(phase_build_state)
   :runs_before(phase_modify_state)
   :not_exist("dev")
   :writes("dev")
   :via(function(state)
      log:trace("inject_device(%s)", state)

      local dev = device()
      return {
         dev = {
            width = dev.width,
            height = dev.height,
            aspect_ratio = dev.aspect_ratio,
            fov = dev.fov,
            frame = dev.frame,
            precache_frame = dev.precache_frame,
            time_delta = dev.time_delta,
            f_time_delta = dev.f_time_delta,
            cam_pos = vector():set(dev.cam_pos),
            cam_right = vector():set(dev.cam_right):normalize(),
            cam_top = vector():set(dev.cam_top):normalize(),
            cam_dir = vector():set(dev.cam_dir):normalize(),
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Inject default camera parameters into the state
inject_camera = system("inject_camera")
   :runs_after(phase_build_state, inject_device)
   :runs_before(phase_modify_state)
   :reads("dev")
   :not_exist("cam")
   :writes("cam")
   :via(function(state)
      log:trace("inject_camera(%s)", state)

      return {
         cam = {
            enable = false,
            pos = vector(),
            rot = vector(),
            smoothing = smoothing:get(),
            show_hud = true,
            affect_hud = true,
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Cache camera parameters into module variables
read_camera = system("read_camera")
   :runs_after(phase_build_state, inject_device, inject_camera)
   :runs_before(phase_modify_state)
   :reads("dev")
   :via(function(state)
      log:trace("read_camera(%s)", state)

      local cam_pos = get_camera_position(state)
      local cam_rot = get_camera_rotation(state)

      if prev_pos then
         delta_pos = vector():set(cam_pos):sub(prev_pos)
         log:trace("  delta_pos: %s", delta_pos)
      end

      if prev_rot then
         delta_rot = vector():set(cam_rot):sub(prev_rot)
         log:trace("  delta_rot: %s", delta_rot)
      end

      prev_pos = cam_pos
      prev_rot = cam_rot

      return {}
   end)
   :during(ACTOR_ON_UPDATE)

--- Apply camera parameters to the game state
apply_camera = system("apply_camera")
   :runs_after(phase_apply_state)
   :runs_before(phase_done)
   :reads("cam")
   :via(function(state)
      log:trace("apply_camera(%s)", state)

      if state.cam.enable then
         log:info("  Applying camera state")
         set_cam_custom_position_direction(
            state.cam.pos,
            state.cam.rot,
            state.cam.smoothing,
            state.cam.show_hud,
            state.cam.affect_hud
         )
         cam_custom = true
      elseif cam_custom then
         log:info("  Resetting camera state.")
         remove_cam_custom_position_direction()
         cam_custom = false
      end

      return {}
   end)
   :during(ACTOR_ON_UPDATE)

