----------------------------------------------------------------------------
-- GoldenOrb: Free Aim Camera Modifier
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Schedule
local LEVEL_CALL = goldenorb_schedule.LEVEL_CALL

--- Main
local goldenorb_before_modify_state = goldenorb_main.goldenorb_before_modify_state
local goldenorb_after_modify_state = goldenorb_main.goldenorb_after_modify_state

--- Hands
local get_hands_position = goldenorb_hands_mcm.get_hands_position
local get_hands_rotation = goldenorb_hands_mcm.get_hands_rotation

--- Aim
local aim_type = goldenorb_aim_mcm.aim_type
local AIM_FREE = goldenorb_aim_mcm.AIM_FREE

--- Schedule
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Free Aim",
   goldenorb_logging.TRACE
)

-- Implementation

free_aim = system("free_aim")
   :runs_after(goldenorb_before_modify_state)
   :runs_before(goldenorb_after_modify_state)
   :reads("actor", "wpn", "joint_aim", "spring_aim", "hands")
   :inputs({ cam = { pos = I_READ, rot = I_READ }})
   :writes("joint_aim")
   :outputs({
      cam = {
         enable = O_WRITE,
         affect_hud = O_WRITE,
         pos = O_WRITE,
         rot = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_FREE
   end)
   :via(function(state)
      local ofs = get_hands_rotation():sub(state.joint_aim.vec):mul(-1)
      log:trace("  ofs: %s", ofs)

      local force = state.spring_aim.spring(ofs)
      log:trace("  force: %s", force)

      local joint_aim = state.joint_aim:impulse(force)
      log:trace("  joint_aim: %s", joint_aim)

      return {
         joint_aim = joint_aim,
         cam = {
            enable = true,
            affect_hud = false,
            pos = state.cam.pos:add(get_hands_position()),
            rot = state.cam.rot:add(joint_aim.vec),
         }
      }
   end)
   :during(LEVEL_CALL)

