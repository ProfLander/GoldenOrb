----------------------------------------------------------------------------
-- GoldenOrb: Hands State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Schedule
local ACTOR_ON_UPDATE = goldenorb_schedule.ACTOR_ON_UPDATE
local LEVEL_CALL = goldenorb_schedule.ACTOR_ON_UPDATE

--- Main
local goldenorb_before_modify_state = goldenorb_main.goldenorb_before_modify_state

--- Impure
local inject_actor = goldenorb_impure.inject_actor

--- Aim
local aim_type = goldenorb_aim_mcm.aim_type
local AIM_FREE = goldenorb_aim_mcm.AIM_FREE

--- Camera
local inject_camera = goldenorb_camera_mcm.inject_camera

--- Weapon
local get_hud_number = goldenorb_weapon.get_hud_number
local inject_weapon_hud = goldenorb_weapon.inject_weapon_hud

--- Math
local deg = lander_math.deg
local hpb_to_direction = lander_math.hpb_to_direction

--- Schedule
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Hands",
   goldenorb_logging.TRACE
)

-- Constants

--- Aim projection distance
local DIST = 1000

-- State

--- Current zoom factor
local zoom_fac = 0

-- Implementation

---@return vector?
function get_hands_position()
   local actor = db.actor
   if not actor then
      log:warning("WARNING: No actor")
      return nil
   end

   return actor:bone_position("bip01", true)
end

---@return vector?
function get_hands_rotation()
   local actor = db.actor
   if not actor then
      log:warning("WARNING: No actor")
      return nil
   end

   return vector():set(actor:bone_direction("bip01", true))
end

---@return vector?
function get_hands_direction()
   local rot = get_hands_rotation()
   return rot and hpb_to_direction(rot)
end

---@return vector
function get_hands_aim_point()
   log:trace("get_hands_aim_point()")
   return get_hands_position()
      :add(
         get_hands_direction()
         :mul(DIST)
      )
end

--- Inject hands data into the given state
inject_hands = system("inject_hands")
   :runs_after(inject_actor)
   :reads("actor")
   :writes("hands")
   :via(function(state)
      log:trace("inject_hands(%s)", state)

      return {
         hands = {
            pos = get_hands_position(),
            rot = get_hands_rotation(),
            dir = get_hands_direction(),
            aim = get_hands_aim_point()
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

---- Consume the HUD hand transforms and store them in the state
consume_hands_transform = system("consume_hands_transform")
   :runs_after(
      inject_actor,
      inject_camera,
      inject_weapon_hud
   )
   :runs_before(goldenorb_before_modify_state)
   :reads("dev")
   :inputs({
      hud = {
         hands_position = I_READ,
         hands_orientation = I_READ,
      },
   })
   :outputs({
      hud = {
         hands_position = O_WRITE,
         hands_orientation = O_WRITE,
      },
      cam = {
         pos = O_WRITE,
         rot = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_FREE
   end)
   :via(function(state)
      local pos = state.hud.hands_position
      local rot = state.hud.hands_orientation

      return {
         hud = {
            hands_position = vector(),
            hands_orientation = vector(),
         },
         cam = {
            pos = vector()
               :add(vector():set(state.dev.cam_right):mul(-pos.x))
               :add(vector():set(state.dev.cam_top):mul(-pos.y))
               :add(vector():set(state.dev.cam_dir):mul(-pos.z)),
            rot = vector(),
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Apply HUD aim offset rotation with a lerp to counteract ADS animation
apply_hud_offset_rot = system("apply_hud_offset_rot")
   :runs_before(goldenorb_before_modify_state)
   :reads("dev", "wpn")
   :inputs({
      hud = {
         aim_hud_offset_rot = I_READ,
         hands_orientation = I_READ,
      }
   })
   :outputs({
      hud = {
         hands_orientation = O_WRITE,
      }
   })
   :via(function(state)
      local zoom_duration = get_hud_number(state.wpn, "zoom_rotate_time")
      if zoom_duration == nil or
         zoom_duration == 0
      then
         zoom_duration = 0.25
      end
      log:debug("  zoom_duration: %s", zoom_duration)

      -- Apply HUD offset rotation based on zoom state
      local rot_ofs = vector():set(
         deg(state.hud.aim_hud_offset_rot.y),
         deg(state.hud.aim_hud_offset_rot.x),
         deg(state.hud.aim_hud_offset_rot.z)
      )

      local dt = (state.dev.time_delta / 1000) / zoom_duration
      log:debug("  dt: %s", dt)
      if not axr_main.weapon_is_zoomed then
         dt = -dt
      end
      zoom_fac = zoom_fac + dt

      zoom_fac = math.min(math.max(zoom_fac, 0), 1)

      log:debug("  zoom_fac: %s", zoom_fac)

      -- Done
      return {
         hud = {
            hands_orientation = vector():set(state.hud.hands_orientation)
               :add(rot_ofs:mul(-(1 - zoom_fac)))
         }
      }
   end)
   :during(LEVEL_CALL)
