----------------------------------------------------------------------------
-- GoldenOrb: Hands State
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Main
local phase_build_state = goldenorb_main.phase_build_state
local phase_modify_state = goldenorb_main.phase_modify_state
local ACTOR_ON_UPDATE = goldenorb_main.ACTOR_ON_UPDATE

--- Impure
local inject_actor = goldenorb_impure.inject_actor

--- Aim
local aim_type = goldenorb_aim_mcm.aim_type
local AIM_FREE = goldenorb_aim_mcm.AIM_FREE

--- Camera
local inject_camera = goldenorb_camera_mcm.inject_camera

--- Weapon
local get_hud_number = goldenorb_weapon.get_hud_number
local inject_weapon = goldenorb_weapon.inject_weapon
local inject_weapon_hud = goldenorb_weapon.inject_weapon_hud

--- Math
local deg = lander_math.deg

--- Schedule
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Hands",
   goldenorb_logging.TRACE
)

-- State

--- Current zoom factor
local zoom_fac = 0

---- Consume the HUD hand transforms and store them in the state
consume_hands_transform = system("consume_hands_transform")
   :runs_after(
      phase_build_state,
      inject_actor,
      inject_camera,
      inject_weapon_hud
   )
   :runs_before(phase_modify_state)
   :reads("dev")
   :inputs({
      hud = {
         hands_position = I_READ,
         hands_orientation = I_READ,
      },
   })
   :outputs({
      hud = {
         hands_position = O_WRITE,
         hands_orientation = O_WRITE,
      },
      cam = {
         pos = O_WRITE,
         rot = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_FREE
   end)
   :body(function(state)
      log:trace("consume_hands_transform(%s)", state)

      local pos = state.hud.hands_position
      local rot = state.hud.hands_orientation

      return {
         hud = {
            hands_position = vector(),
            hands_orientation = vector(),
         },
         cam = {
            pos = vector()
               :add(vector():set(state.dev.cam_right):mul(-pos.x))
               :add(vector():set(state.dev.cam_top):mul(-pos.y))
               :add(vector():set(state.dev.cam_dir):mul(-pos.z)),
            rot = vector(),
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

--- Apply HUD aim offset rotation with a lerp to counteract ADS animation
apply_hud_offset_rot = system("apply_hud_offset_rot")
   :runs_after(
      phase_build_state,
      inject_weapon,
      inject_weapon_hud
   )
   :runs_before(phase_modify_state)
   :reads("dev", "wpn")
   :inputs({
      hud = {
         aim_hud_offset_rot = I_READ,
         hands_orientation = I_READ,
      }
   })
   :outputs({
      hud = {
         hands_position = O_WRITE,
         hands_orientation = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_FREE
   end)
   :body(function(state)
      log:trace("apply_hud_offset_rot(%s)", state)

      local zoom_duration = get_hud_number(state.wpn, "zoom_rotate_time")
      if zoom_duration == nil or
         zoom_duration == 0
      then
         zoom_duration = 0.25
      end
      log:debug("  zoom_duration: %s", zoom_duration)

      -- Apply HUD offset rotation based on zoom state
      local rot_ofs = vector():set(
         deg(state.hud.aim_hud_offset_rot.y),
         deg(state.hud.aim_hud_offset_rot.x),
         deg(state.hud.aim_hud_offset_rot.z)
      )

      local dt = (state.dev.time_delta / 1000) / zoom_duration
      log:debug("  dt: %s", dt)
      if not axr_main.weapon_is_zoomed then
         dt = -dt
      end
      zoom_fac = zoom_fac + dt

      zoom_fac = math.min(math.max(zoom_fac, 0), 1)

      log:debug("  zoom_fac: %s", zoom_fac)

      -- Done
      return {
         hud = {
            hands_position = vector(),
            hands_orientation = vector():set(state.hud.hands_orientation)
               :add(rot_ofs:mul(-(1 - zoom_fac)))
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)
