----------------------------------------------------------------------------
-- GoldenOrb: Bodycam Camera Modifier
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- HUD offset rotation
local apply_hud_offset_rot = goldenorb_mod_hud_offset_rot.apply_hud_offset_rot

--- Math
local deg = lander_math.deg

--- Camera
local get_camera_aim_point = goldenorb_camera.get_camera_aim_point

--- Weapon
local get_hands_position = goldenorb_weapon.get_hands_position

--- MCM Builder
local ImageWithText = mcm_builder.ImageWithText
local Checkbox = mcm_builder.Checkbox

--- Logging
local log = goldenorb_logging.log

-- Constants

BONE_ROOT = "root_stalker"

-- State

page = goldenorb_mcm.tree:pages("bodycam")
page:settings(ImageWithText.new("body_cam_title"):text("body_cam"))
local enabled = page:settings(Checkbox.new("enabled"):default(false))

--- Set of bones used to calculate camera transform
BONES = {
   bip01_head = {
      vector():set(0.33, 0.33, 0.33),
      vector():set(0.25, 0.1, 0.25),
   },
   bip01_neck = {
      vector():set(0.33, 0.33, 0.33),
      vector():set(0.15, 0.25, 0.25),
   },
   bip01_spine2 = {
      vector():set(0.33, 0.33, 0.33),
      vector():set(0.0, 0.25, 0.25),
   },
}

-- Implementation

function get_actor_rotation(wpn)
   log("get_actor_rotation")
   local actor = db.actor

   log("  actor: %s", actor)

   local cam_aim = get_camera_aim_point(wpn)
   log("  cam_aim: %s", cam_aim)

   local actor_pos = actor:position()
   log("  actor_pos: %s", actor_pos)

   local actor_dir = actor:direction()
   log("  actor_dir: %s", actor_dir)

   local actor_aim = vector()
      :set(actor:position())
      :add(actor:direction():mul(800))
   log("  actor_aim: %s", cam_aim)

   local hands_pos = get_hands_position()
   log("  hands_pos: %s", hands_pos)

   local cam_loc = cam_aim:sub(hands_pos):normalize()
   log("  cam_loc: %s", cam_loc)

   local actor_loc = actor_aim:sub(hands_pos):normalize()
   log("  actor_loc: %s", actor_loc)

   local pitch = math.sin(cam_loc.y - actor_loc.y)
   log("  pitch: %s", pitch)

   cam_loc.y = 0
   actor_loc.y = 0

   local yaw = math.atan2(
      vector_cross(cam_loc, actor_loc)
      :dotproduct(vector():set(0, 1, 0)),
      cam_loc:dotproduct(actor_loc)
   )
   log("  yaw: %s", yaw)

   return vector():set(yaw, pitch, 0)
end

function body_cam(state)
   log("body_cam(%s)", state)

   if not enabled:get() then
      return state
   end

   if not state.actor then
      return state
   end

   for k,v in pairs(state.actor:list_bones()) do
      printf("%s: %s", k, v)
   end

   local root_pos = state.actor:bone_position(BONE_ROOT)
   log("root_pos: %s", root_pos)

   local root_rot = state.actor:bone_direction(BONE_ROOT)
   log("root_rot: %s", root_rot)

   local pos = vector()
   local rot = vector()
   for bone,facs in pairs(BONES) do
      local pos_fac = facs[1]
      local rot_fac = facs[2]
      pos:add(
         state.actor:bone_position(bone)
         :sub(root_pos)
         :mul(pos_fac)
      )
      rot:add(
         state.actor:bone_direction(bone)
         :sub(root_rot)
         :mul(rot_fac)
      )
   end

   pos:add(root_pos)
   rot:add(root_rot)

   state.cam.enable = true
   state.cam.pos = pos
   state.cam.rot = vector():set(rot.x, rot.y, 0)
   state.cam.affect_hud = true

   if state.wpn and state.hud then
      local actor_rot = get_actor_rotation(state.wpn)
      state.hud.hands_orientation.x =
         state.hud.hands_orientation.x
         - deg(actor_rot.x)

      state.hud.hands_orientation.y =
         state.hud.hands_orientation.y
         + deg(actor_rot.y)
   end

   return state
end

function on_game_start()
   goldenorb_main.ACTOR_ON_UPDATE
      :after(apply_hud_offset_rot, body_cam)
end
