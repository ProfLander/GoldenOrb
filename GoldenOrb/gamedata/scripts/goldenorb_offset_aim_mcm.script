----------------------------------------------------------------------------
-- GoldenOrb: Offset Aim Camera Modifier
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- HUD offset rotation
local phase_modify_state = goldenorb_main.phase_modify_state
local phase_apply_state = goldenorb_main.phase_apply_state

--- Aim
local page = goldenorb_aim_mcm.page
local aim_type = goldenorb_aim_mcm.aim_type
local AIM_OFFSET = goldenorb_aim_mcm.AIM_OFFSET

--- Data
local get_camera_delta_rotation = goldenorb_camera_mcm.get_camera_delta_rotation

--- String
local parse_vector = goldenorb_string.parse_vector

--- Schedule
local LEVEL_CALL = goldenorb_schedule.LEVEL_CALL
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- MCM Builder
local Line = mcm_builder.Line
local Title = mcm_builder.Title
local InputField = mcm_builder.InputField

--- Math
local RAD2DEG = lander_math.RAD2DEG

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Offset Aim",
   goldenorb_logging.TRACE
)

-- State

--- MCM Title
page:settings(
   Line.new(),
   Title.new("offset_aim_title"):text("offset_aim")
)

--- MCM Settings
local sensitivity = page:settings(
   InputField.new("sensitivity")
      :default("1.0,1.0")
)

-- Implementation

offset_aim = system("offset_aim")
   :runs_after(phase_modify_state)
   :runs_before(phase_apply_state)
   :reads("joint_aim", "spring_aim")
   :inputs({
      hud = {
         hands_orientation = I_READ,
      }
   })
   :writes("joint_aim")
   :outputs({
      hud = {
         hands_orientation = O_WRITE,
      }
   })
   :when(function()
      return aim_type:get() == AIM_OFFSET
   end)
   :via(function(state)
      local joint_aim = state.joint_aim
         :impulse(
            get_camera_delta_rotation()
            :mul(parse_vector(sensitivity:get()))
            :mul(vector():set(-1, 1, 1))
         )
         :impulse_with(state.spring_aim.spring)

      return {
         joint_aim = joint_aim,
         hud = {
            hands_orientation = vector():set(state.hud.hands_orientation)
               :add(vector():set(joint_aim.vec):mul(RAD2DEG))
         }
      }
   end)
   :during(LEVEL_CALL)
