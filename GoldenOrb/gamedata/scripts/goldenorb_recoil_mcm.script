----------------------------------------------------------------------------
-- GoldenOrb: Recoil
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- Goldenorb
local tree = goldenorb_mcm.tree

--- Main
local ACTOR_ON_UPDATE = goldenorb_main.ACTOR_ON_UPDATE
local phase_modify_state = goldenorb_main.phase_modify_state
local phase_apply_state = goldenorb_main.phase_apply_state
local handle_error = goldenorb_main.handle_error

--- Modifiers
local body_cam = goldenorb_body_cam_mcm.body_cam
local free_aim = goldenorb_free_aim_mcm.free_aim
local offset_aim = goldenorb_offset_aim_mcm.offset_aim

--- Joint
local joint = goldenorb_joint.joint

--- Lens
local lens = goldenorb_lens.lens

--- Spring
local spring_1d = goldenorb_spring.spring_1d

--- Table
local foreach = goldenorb_table.foreach

--- Math
local deg = lander_math.deg

--- Function
local protected = goldenorb_function.protected

--- Schedule
local system = goldenorb_schedule.system
local I_READ = goldenorb_schedule.I_READ
local O_WRITE = goldenorb_schedule.O_WRITE

--- MCM Builder
local Trackbar = mcm_builder.Trackbar

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Recoil",
   goldenorb_logging.TRACE
)

-- Constants

--- Lenses for interacting with weapon parameters
local lenses = {
   cam_relax_speed = lens(
      "GetCamRelaxSpeed",
      "SetCamRelaxSpeed"
   ),
   cam_dispersion = lens(
      "GetCamDispersion",
      "SetCamDispersion"
   ),
   cam_dispersion_inc = lens(
      "GetCamDispersionInc",
      "SetCamDispersionInc"
   ),
   cam_dispersion_frac = lens(
      "GetCamDispersionFrac",
      "SetCamDispersionFrac"
   ),
   cam_max_angle_vert = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   cam_max_angle_horz = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   cam_step_angle_horz = lens(
      "GetCamStepAngleHorz",
      "SetCamStepAngleHorz"
   ),
   zoom_cam_relax_speed = lens(
      "GetZoomCamRelaxSpeed",
      "SetZoomCamRelaxSpeed"
   ),
   zoom_cam_dispersion = lens(
      "GetZoomCamDispersion",
      "SetZoomCamDispersion"
   ),
   zoom_cam_dispersion_inc = lens(
      "GetZoomCamDispersionInc",
      "SetZoomCamDispersionInc"
   ),
   zoom_cam_dispersion_frac = lens(
      "GetZoomCamDispersionFrac",
      "SetZoomCamDispersionFrac"
   ),
   zoom_cam_max_angle_vert = lens(
      "GetZoomCamMaxAngleHorz",
      "SetZoomCamMaxAngleHorz"
   ),
   zoom_cam_max_angle_horz = lens(
      "GetCamMaxAngleHorz",
      "SetCamMaxAngleHorz"
   ),
   zoom_cam_step_angle_horz = lens(
      "GetZoomCamStepAngleHorz",
      "SetZoomCamStepAngleHorz"
   ),
}

-- State

local page = tree:pages("recoil")

local kick_multiplier, control_strength = page:settings(
   Trackbar.new("kick_multiplier")
      :default(8)
      :minmax(1, 32)
      :increment(1),
   Trackbar.new("control_strength")
      :default(0.05)
      :minmax(0, 1)
      :increment(0.01)
)

local spring_recoil = goldenorb_spring.mcm_spring(
   page,
   SP_ANGULAR,
   "0,0",
   "0.05,0.05"
)

--- Weapon data cache
local wpn_cache = {}

--- How under-control the weapon is
local control_fac = 0

--- Recoil joint
local joint_recoil = joint()

-- Implementation

function actor_on_weapon_fired_impl(actor, wpn, ammo)
   log:trace("actor_on_weapon_fired(%s, %s, %s)", actor, wpn, ammo)

   control_fac = control_fac + kick_multiplier:get()

   local id = wpn:id()
   log:debug("  id: %s", id)

   local sec = wpn:section()
   log:debug("  sec: %s", sec)

   local cache = wpn_cache[sec]
   if not cache then
      log:info("No cached recoil information")
      return
   end

   -- Fetch weapon recoil stats
   local wpn_disp = nil
   local wpn_frac = nil
   local wpn_inc = nil
   local wpn_max_vert = nil
   local wpn_max_horz = nil
   local wpn_step_horz = nil

   if axr_main.weapon_is_zoomed then
      wpn_disp = cache.zoom_cam_dispersion
      wpn_frac = cache.zoom_cam_dispersion_frac
      wpn_inc = cache.zoom_cam_dispersion_inc
      wpn_max_vert = cache.zoom_cam_max_angle_vert
      wpn_max_horz = cache.zoom_cam_max_angle_horz
      wpn_step_horz = cache.zoom_cam_step_angle_horz
   else
      wpn_disp = cache.cam_dispersion
      wpn_frac = cache.cam_dispersion_frac
      wpn_inc = cache.cam_dispersion_inc
      wpn_max_vert = cache.cam_max_angle_vert
      wpn_max_horz = cache.cam_max_angle_horz
      wpn_step_horz = cache.cam_step_angle_horz
   end

   -- Gather ammo box list
   local ammo_list_n = utils_item.get_ammo(sec, id)

   -- Gather weapon info
   local ammo_type = wpn:get_ammo_type()
   local ammo_sec = ammo_list_n[ammo_type + 1]
   ---@diagnostic disable-next-line: undefined-field
   local ammo_disp = ini_sys:r_float_ex(ammo_sec, "k_cam_disp") or 1

   -- Fetch silencer recoil stats
   ---@diagnostic disable-next-line: undefined-field
   local silencer = ini_sys:r_string_ex(sec, "silencer_name")
   log:debug("  silencer: %s", silencer)

   local silencer_disp = silencer
      ---@diagnostic disable-next-line: undefined-field
      and ini_sys:r_string_ex(silencer, "cam_dispersion_k") or 1
   local silencer_inc = silencer
      ---@diagnostic disable-next-line: undefined-field
      and ini_sys:r_string_ex(silencer, "cam_dispersion_inc_k") or 1

   log:debug("  silencer_disp: %s", silencer_disp)
   log:debug("  silencer_inc: %s", silencer_inc)

   local disp = wpn_disp * silencer_disp * ammo_disp
   local inc = wpn_inc * silencer_inc * (control_fac + 1)

   local ang = disp + inc

   local rnd = (math.random() - 1) * 2
   local recoil_y = ang * (wpn_frac + rnd * (1 - wpn_frac))
   log:debug("  recoil_y: %s", recoil_y)

   rnd = (math.random() - 1) * 2
   local recoil_x = (joint_recoil.vec.y / wpn_max_vert) * rnd * wpn_step_horz
   log:debug("  recoil_x: %s", recoil_x)

   joint_recoil:impulse(vector():set(recoil_x, recoil_y, 0))
   log:debug("  joint: %s", joint_recoil.vec)
end

function actor_on_weapon_fired(...)
   local res, out = pcall(actor_on_weapon_fired_impl, ...)
   if not res then
      ---@cast out string
      handle_error(out)
   end
end

--- Cache a weapon's HUD data before setting it all to 0
consume_weapon = system("consume_weapon")
   :runs_after(phase_modify_state)
   :runs_before(phase_apply_state)
   :reads("wpn")
   :via(function(state)
      log:trace("consume_weapon(%s)", state)

      -- Fetch the weapon's section
      local sec = state.wpn:section()
      log:debug("  section(%s)", sec)

      -- Return with a warning if it's not valid
      if not sec then
         log:warning("  WARNING: Invalid weapon section")
         return {}
      end

      -- Return if it's already set
      if wpn_cache[sec] then
         log:info("  %s is already cached, returning.", sec)
         return {}
      end

      -- Fetch existing cache data
      wpn_cache[sec] = {}

      -- Cast our weapon to a CWeapon
      local weapon = state.wpn:cast_Weapon()

      if not weapon then
         log:warning("  WARNING: Invalid weapon")
         return {}
      end

      -- Iterate over our parameter lenses
      foreach(
         lenses,
         function(k, l)
            wpn_cache[sec][k] = l:get(weapon)
            l:set(weapon, 0)
         end
      )

      return {}
   end)
   :during(ACTOR_ON_UPDATE)

--- Integrate recoil forces and apply to the HUD
recoil_weapon = system("recoil_weapon")
   :runs_after(
      phase_modify_state,
      consume_weapon,
      body_cam,
      free_aim,
      offset_aim
   )
   :runs_before(phase_apply_state)
   :inputs({
      hud = {
         hands_orientation = I_READ
      }
   })
   :outputs({
      hud = {
         hands_orientation = O_WRITE
      }
   })
   :via(function(state)
      log:trace("recoil_weapon(%s)", state)

      control_fac = control_fac + spring_1d(
         0,
         control_strength:get(),
         control_fac
      )
      log:debug("  control_fac: %s", control_fac)

      joint_recoil:impulse_with(spring_recoil.spring)

      return {
         hud = {
            hands_orientation = state.hud.hands_orientation:add(
               vector():set(
                  deg(joint_recoil.vec.x),
                  deg(joint_recoil.vec.y),
                  deg(joint_recoil.vec.z)
               )
            )
         }
      }
   end)
   :during(ACTOR_ON_UPDATE)

---@return nil
on_game_start = protected(
   handle_error,
   function()
      RegisterScriptCallback("actor_on_weapon_fired", actor_on_weapon_fired)
   end
)
