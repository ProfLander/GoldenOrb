----------------------------------------------------------------------------
-- GoldenOrb: Schedule
----------------------------------------------------------------------------
-- Object-oriented dependent function scheduling.
----------------------------------------------------------------------------
-- Implemented by Lhan
----------------------------------------------------------------------------

-- Imports

--- List
local fold_list = goldenorb_list.fold
local concat_lists = goldenorb_list.concat

--- Table
local fold_table = goldenorb_table.fold

--- Function
local const = goldenorb_function.const

--- Logging
local log = goldenorb_logging.logger(
   "GoldenOrb/Schedule",
    goldenorb_logging.WARNING
)

-- Constants

--- Input enum
--- Data exists
I_EXIST = 0
--- Data does not exist
I_NOT_EXIST = 1
--- Read data, asserting non-nil
I_READ = 2
--- Read data, allowing nil
I_READ_MAYBE = 3

--- Output enum
--- Write data, nil included
O_WRITE = 0
--- Write data if non-nil
O_WRITE_MAYBE = 1

-- Implementation

--- Schedule metatable
---@class schedule
---@field start fun(any: any): any
---@field finish fun(any: any): any
---@field calls (fun(any: any): any)[]
---@field rules [fun(any: any): any, fun(any: any): any]
---@field schedule (fun(any: any): any)[]
local Schedule = {}

--- Schedule constructor
---@return schedule
function schedule(name)
   local function start(...)
      log:trace("%s: Start", name)
      return ...
   end

   local function finish(...)
      log:trace("%s: Finish", name)
      return ...
   end

   return setmetatable(
      {
         start = start,
         finish = finish,
         calls = {
            {start, {}, {}, const(true)},
            {finish, {}, {}, const(true)}
         },
         rules = {
            {start, finish}
         },
         schedule = nil,
      },
      { __index = Schedule }
   )
end

---@return nil
function Schedule:invalidate()
   log:trace("Schedule:invalidate()")
   self.schedule = nil
end

---@param f fun(...: any): any
---@param inputs number|table<string, number|table>
---@param outputs table<string, any>
---@return schedule
function Schedule:add_call(f, inputs, outputs, precondition)
   log:trace("Schedule:add_call(%s)", f)
   if type(f) ~= "function" then
      assert(nil, string.format("Invalid call: %s", f))
   end
   if type(inputs) ~= "number" and type(inputs) ~= "table" then
      assert(nil, string.format("Invalid inputs: %s", inputs))
   end
   if type(outputs) ~= "table" then
      assert(nil, string.format("Invalid outputs: %s", outputs))
   end
   if type(precondition) ~= "function" then
      assert(nil, string.format("Invalid precondition: %s", precondition))
   end
   self:invalidate()
   table.insert(self.calls, {f, inputs, outputs, precondition})
   return self
end

---@param fa fun(any: any): any
---@param fb fun(any: any): any
---@return schedule
function Schedule:add_rule(fa, fb)
   log:trace("Schedule:add_rule(%s, %s)", fa, fb)
   assert(fa ~= nil, "Invalid rule LHS")
   assert(fb ~= nil, "Invalid rule RHS")
   assert(fa ~= fb, "Cannot constrain a call to run relative to itself")
   self:invalidate()
   table.insert(self.rules, {fa, fb})
   return self
end

--- Return the number of elements for which F returns true
function count(lst, f)
   return fold_list(
      lst,
      0,
      function(acc, next)
         return f(next) and (acc + 1) or acc
      end
   )
end

--- Curried equality check
function eq(a)
   return function(b)
      return a == b
   end
end

--- Curried inequality check
function ne(a)
   return function(b)
      return a ~= b
   end
end

---@class system
---@field sys_name string
---@field sys_after (fun(any: any): any)[]
---@field sys_before (fun(any: any): any)[]
---@field sys_inputs table<string, number|table>
---@field sys_outputs table<string, number|table>
---@field sys_precondition (fun(table): boolean)
---@field sys_body fun(state: table): table
local System = {}

function system(name)
   return setmetatable(
      {
         sys_name = name,
         sys_after = {},
         sys_before = {},
         sys_inputs = {},
         sys_outputs = {},
         sys_precondition = const(true),
         sys_body = nil,
      },
      { __index = System }
   )
end

function System:runs_after(...)
   self.sys_after = concat_lists(self.sys_after, {...})
   return self
end

function System:runs_before(...)
   self.sys_before = concat_lists(self.sys_before, {...})
   return self
end

function System:inputs(inputs)
   copy_table(self.sys_inputs, inputs)
   return self
end

function System:outputs(outputs)
   copy_table(self.sys_outputs, outputs)
   return self
end

---@param input string
---@return system
function System:exist(input)
   self.sys_inputs[input] = I_EXIST
   return self
end

---@param input string
---@return system
function System:not_exist(input)
   self.sys_inputs[input] = I_NOT_EXIST
   return self
end

---@param ... string
---@return system
function System:reads(...)
   local args = {...}
   for i=1,#args do
      self.sys_inputs[args[i]] = I_READ
   end
   return self
end

---@param ... string
---@return system
function System:maybe_reads(...)
   local args = {...}
   for i=1,#args do
      self.sys_inputs[args[i]] = I_READ_MAYBE
   end
   return self
end

---@param ... string
---@return system
function System:writes(...)
   local args = {...}
   for i=1,#args do
      self.sys_outputs[args[i]] = O_WRITE
   end
   return self
end

---@param ... string
---@return system
function System:maybe_writes(...)
   local args = {...}
   for i=1,#args do
      self.sys_outputs[args[i]] = O_WRITE_MAYBE
   end
   return self
end

function System:when(f)
   self.sys_precondition = f
   return self
end

function System:body(f)
   self.sys_body = f
   return self
end

function System:during(schedule)
   assert(self.sys_body ~= nil, "Systems must have a body")

   schedule:insert(
      self.sys_body,
      self.sys_after,
      self.sys_before,
      self.sys_inputs,
      self.sys_outputs,
      self.sys_precondition
   )

   return self.sys_body
end

---@param call fun(any: any): any
---@param after? (fun(any: any): any)[]
---@param before? (fun(any: any): any)[]
---@param inputs? number|table
---@param outputs? table
---@param precondition? function(state: table): boolean
function Schedule:insert(call, after, before, inputs, outputs, precondition)
   log:trace(
      "Schedule:insert(%s, %s, %s, %s, %s)",
      call,
      after,
      before,
      inputs,
      outputs
   )

   -- Typecheck inputs
   if type(call) ~= "function" then
      assert(nil, string.format("Invalid call: %s", call))
   end

   after = after or {}
   before = before or {}
   inputs = inputs or {}
   outputs = outputs or {}
   precondition = precondition or const(true)

   assert(
      count(after, eq(call)) == 0,
      "After rules must not mention their associated call"
   )

   assert(
      count(before, eq(call)) == 0,
      "Before rules must not mention their associated call"
   )

   if #after == 0 then
      table.insert(after, self.start)
   end

   if #before == 0 then
      table.insert(before, self.finish)
   end

   self:add_call(call, inputs, outputs, precondition)
   for i=1,#after do
      self:add_rule(after[i], call)
   end
   for i=1,#before do
      self:add_rule(call, before[i])
   end
   return self
end

---@return schedule
function Schedule:build()
   log:trace("Schedule:build()")

   self.schedule = {}

   log:debug("  calls: %s", #self.calls)
   log:debug("  rules: %s", #self.rules)

   local called = {}
   local count = 0
   while count < #self.calls do
      log:trace("  count: %s", count)
      for _,tup in ipairs(self.calls) do
         local call = tup[1]
         log:trace("  call: %s", call)
         if called[call] then
            log:trace("    already called")
            goto next_call
         end

         for _,rule in ipairs(self.rules) do
            log:debug("    rule: %s -> %s", rule[1], rule[2])

            -- If the rule doen't mention the call, skip it
            if rule[2] ~= call then
               log:debug("      not relevant")
               goto next_rule
            end

            -- If the call is the target of the rule
            -- and its dependency is not met, skip it
            if not called[rule[1]] then
               log:debug("      not satisfied")
               goto next_call
            end

            log:debug("      pass")

            ::next_rule::
         end

         log:debug("  pass")

         -- If all rules pass, call the function
         table.insert(self.schedule, tup)
         called[call] = true
         count = count + 1
         goto next_iter

         ::next_call::
      end

      assert(nil, "Unsolvable dependency graph")

      ::next_iter::
   end

   return self
end

---@param tbl table<any, any>
---@param paths number|table<any, boolean|table>
---@return table<any, any>
function slice(tbl, paths)
   log:trace("slice(%s, %s)", tbl, paths)

   -- Special case: Retrieve entire state with an I_READ
   if paths == I_READ then
      return tbl
   end

   if type(tbl) ~= "table" then
      assert(nil, string.format("Invalid table: %s", tbl))
   end

   if type(paths) ~= "table" then
      assert(nil, string.format("Invalid paths: %s", paths))
   end

   ---@cast paths table
   return fold_table(
      paths,
      {},
      function(acc, k, v)
         if acc == nil then
            -- Short-circuit if the accumulator is nil
            return nil
         end

         local entry = tbl[k]

         if entry == nil and (v == I_EXIST or v == I_READ) then
            -- Don't run unless the value exists
            return nil
         end

         if entry ~= nil and v == I_NOT_EXIST then
            -- Don't run unless the value does not exist
            return nil
         end

         if v == I_EXIST or v == I_NOT_EXIST then
            -- Return the state unmodified
            return acc
         elseif v == I_READ or v == I_READ_MAYBE then
            -- Read the value
            acc[k] = entry
         elseif type(v) == "table" then
            -- If there is nothing to slice, fail
            if not entry then
               return nil
            end

            -- Recursively slice the encountered value
            local sub = slice(entry, v)

            -- If the slice failed, propagate the failure upward
            if sub == nil then
               return nil
            end

            -- Otherwise, emplace the sub-slice
            acc[k] = sub
         else
            -- Anything else is invalid
            assert(nil, string.format("Invalid path type: %s", v))
         end

         return acc
      end
   )
end

---@param tbl table<any, any>
---@param vals table<any, any>
---@return table<any, any>
function merge(tbl, vals, paths)
   log:trace("merge(%s, %s, %s)", tbl, vals, paths)

   return fold_table(
      paths,
      tbl,
      function(acc, k, path)
         local v = vals[k]

         log:debug("  path: %s", path)
         log:debug("  v: %s", v)

         if path == nil then
            -- If there is no path, do nothing
            return acc
         end

         if (path == O_WRITE_MAYBE or type(path) == "table") and v == nil then
            -- If this is an optional write and there is no value, early-out
            return acc
         end

         if type(path) == "table" then
            if v == nil then
               assert(
                  nil,
                  string.format("Expected a table for key %s", k)
               )
            end
            -- If the path is composite, recurse
            acc[k] = merge(acc[k], v, path)
         else
            -- If the path represents a write, emplace by value
            if acc[k] ~= nil and type(v) == "table" then
               assert(type(acc[k]) == "table", "Type mismatch")
               copy_table(acc[k], v)
            else
               acc[k] = v
            end
         end

         return acc
      end
   )
end

--- Run the schedule with the given parameter and return its result
---@param p any
---@return any
function Schedule:run(p)
   log:trace("Schedule:run(%s)", p)

   if not self.schedule then
      self:build()
   end

   return fold_list(
      self.schedule,
      p,
      function(acc, tup)
         local f = tup[1]
         local inputs = tup[2]
         local outputs = tup[3]
         local precondition = tup[4]

         if not precondition(acc) then
            -- If the precondition fails, don't run
            return acc
         end

         local res = slice(acc, inputs)
         if res == nil then
            -- If the slice failed, don't invoke the function
            return acc
         end

         -- If the slice succeeded,
         -- invoke the function and merge its results with the state
         return merge(
            acc,
            f(res),
            outputs
         )
      end
   )
end

--- Run the schedule with the given error handler and parameter,
--- and return its result
---@param e fun(err: string, stack: string): any
---@param p any
---@return any
function Schedule:prun(e, p)
   log:trace("Schedule:prun(%s, %s)", e, p)
   local status, res = pcall(self.run, self, p)
   if not status then
      local stack = callstack(false, true)
      ---@cast stack string
      return e(res, stack)
   end
   return res
end

--- Produce a function to run the schedule,
--- optionally overriding its input
---@param pf fun(): any
---@return fun(pb: any): any
function Schedule:run_deferred(pf)
   return function(pb)
      return self:run(pf and pf() or pb)
   end
end

--- Produce a function to prun the schedule,
--- optionally overriding its input
---@param e fun(any: any): any
---@return fun(pb: any): any
function Schedule:prun_deferred(e, pf)
   return function(p)
      return self:prun(e, pf and pf() or p)
   end
end
